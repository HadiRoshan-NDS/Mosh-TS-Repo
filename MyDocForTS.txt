--** SECTION1 **--

- TypeScript is a programming language developed by Microsoft to address the shortcomings of JavaScript.

- Every JS file is a valid TS file.

- Features (Benefits) of TypeScript:
+Static Typing
+Code completion
+Refactoring
+Shorthand notations

* There are two types of programming languages: Statically-Typed and Dynamically-Typed
+In Staticaly-typed languages (eg. C#, Java) we know the type of variables at compile time (while coding) 
+In Dynamically-typed languages (eg. JS, Python) the types of variables are deteremined at runtime and can change

- In TS we explicitly declare the types of variables upon declaration

- The drawback of TS is there always is a compile time because we have to pass it through a TS compiler

- The process of turning TS code into JS code is called Transpilation

- We have installed the TSCompiler using <npm i -g typescript> and can check the version by running <tsv -v)

- To create a TS file, we run <tsc --init>

- The target setting in the config file is the version of JS that the compiler is going to generate.

- In the module section setting there is a rootDir setting which specifies the directory containing our source file

- After compilation, our JS files will be stored in the dist folder, so we change outDir under Emit to ./dist

- If we set removeComments to false, the compiler will remove all the comments

- If the noEmitOnError setting is true, if there are mistakes in our TS fiel, the compiler won't generate any JS

- If we run <tsc> in the terminal, the compiler will compiler our TS code

- The sourcemap setting is a file that specifies how each line of our TS code maps to the generated JS code

- For debugging, we navigate to the debugging panel, select create a launcfh.json file, then select Node.js

- In the launch.json file, we add a new setting under program named preLaunchTask and set to "tsc: build - tsconfig.json"
In this setting we tell vscode to compile our application using the tscompiler with this configuration

--** SECTION2: Fundamentals **--

- TS has some additional types compared with JS which makes it different than JS.

- In TS, we don't always have to annotate our variables. The compiler can infer or detect the type of our variabels
based on their values. For instance, when we initialize a variable to a number, the compiler knows that the variable
is a number. If we don't initialize a variable, the compiler will assume its type as any.

- When we define a variable with the type any, we can assign any value to it but it is against the whole idea of TS
so it wouldn't be logical.

- Assuming we have a JS project which uses undefined arguments in its functions, there are two things we can do, first, we can
define its type of any in where its used as an argument to tell the compiler that we know whart we're doing. The second
thing we can do is use control+p shortcut and go to tsconfig.json and set the noImplicitAny to false.

- Tuple is another data type which is a fixed length array where each element has a particular type. We often use them
while working with a pair of values.

- We can access the methods for arrays using a dot after the name of the array, one of the methods which can be 
troublesome is push(), so if we use it for a tuple, the compiler won't complain, Mosh suggests to only use tuples
while defining two elements, because more than that would be hard to figure out.

- Enum is another built-in data type which represents a list of related constants. (like C#)

- We have an option in the tsconfig.json file which allows us to avoid using unused arguments, so we wouldn't put
an argument in the parentheses which we're not going to use. In the typeChecking section we have an option called
noUnusedParameters which we can set to true.

- We have another option in tsconfig.json for detecting when we're not returning a proper value for a function, the 
option is called noImplicitReturns, we can set it to true and it will warn us when needed.

--** SECTION3: Advanced Types **--

- We can use a type alias to define a custom type. 

- With union (|) types, we can give a variable or a function parameter more than one type

- Another way to use multiple types for a variable is an intersection (&)

- Sometimes we want to limit the values we can assign to variables, here we use literals

- TS is strict about using null and undefined values in our apps because they are on of the main sources of bugs.

- If we hover over phone in the ls25 file, we see that it's either an HTML Element or null, in case it wasn't found.

- We have learned about the any type earlier in the course and know that we should avoid it as much as possible.

- If we define a function with an argument of type any, we can use whatever function we want and the compiler won't complain
but in runtime the app might crash.

- One thing we can do is change the type from any to unknown which will lead to the compiler complaining about using various
functions, we can also do type narrowing to use functions suitable for each type.

- In our tsconfig file, the type checking section, there is an option called allowUnreachableCode which we can turn off, now
in the never type file, we see that the compiler won't let us write any code after a function that doesn't return

- If we do not annotate the return type of an infinite loop function, the compiler will assume its void, and the code after
the function will not generate any errors.

--** SECTION4: Object-Oriented Programming **--

- OOP is one of the most important programming paradigms.

- An object is a unit that contains some data (also) and operations (behavior).

- If we consider a person an object, name and email would be properties, talk and dance could be methods for person.

- We could have individual objects for LoginForm, AuthService, EmailService, etc.

- A class is a blueprint for creating objects.

- If we want to represent the concept of a bank account, we need a class for that. We can have properties like id,
owner, and balance; we can also have methods like deposit, and withdraw.

- We use the Pascal naming convetion for classes (capitalize the first letter of EVERY word).

- A constructor is a special method inside a class, that is used for initializing an object.

- A constructor cannot have a return type annotation. 

- If we type this in a construcor and type a dot after it, we can see all the properties defined earlier. 

- After compilation when we look at the JS file, we see that we don't have any properties, we just have a constructor
where the types of arguments are not mentioned, and we also have the deposit method.

- In lesson 32, we will use the ls31 file and create an instance (object) of the defined class.

- We have created an object called account which is an instance of Account and passed the required arguments. When we
type account with dot after it, we can see the properties and methods for this object.

- We can use this command to compile a ts project in a specific path:
tsc -p D:\Projects\tsApps\section4OOP\ls31Class

- If we print the account object itself in the terminal, we will see all of its properties.

- If we print the typeof an object instance of a class, we get object.

- We can use instanceof to check to see whether an object is an insatnce of a specific class.

-ls33: In TS we have modifiers that we can apply to our properties and help us make more robust code. Let's say in our
code, the id of a bank account should never change, right now it can change. For example we can set its value to 0 in
the body of the deposit method. We can prefix this property with the readonly keyword and make it unchangeable. 

- Now let's say we want to define an optional property, for instance a nickname. We can add a question mark after the
property to make it optional. 

-ls34: There are more access control modifiers that we can use. Assume we want to implement a transaction on deposit
and withdraw, so we know how much money was transferred from who to where. We want to have an array for transactions 
which is an array of transaction objects. So before we change the balance we want to record the transaction. If we
want to modify the balance somewhere other than in the body of deposit, the transaction wouldn't be recorded and that
is a problem, so we should do something to limit access.

- In TypeScript we have 3 Access Modifiers. We have public, private and protected. When we define properties, they are
public by default. But if we use the private keyword for a property, it would be accessible only within that class. We
use this private keyword to make our code robust, not for storing private information. By convention, when we want to
make a property private, we prefix it with an underline. 

- We have made bance private, so when we want to display the balance to the user, we cannot access it because we are
outside of the Account class. One solution is to define a getBalance method inside the class which return the balance,
then we can call the method outside of the class for displaying the balance.

- We can also define private methods, so let's assume we want to define a calculateTax method and access it internally.

-ls35: In the constructor, we have 3 lines of code for initializing the three properties from the arguments. In the
line where we define the constructor, we can prefix the parameters with a public keyword, it tells the compiler to 
create a property with that name and initialize it in one go. This way we can get rid of the line at the top where 
we defined id as a readonly property and also the code in the constructor where we initialize it. We can also add the
readonly modifier for the parameter. These 3 keywords we used are parameter properties.

- ls36: With the current approach, we are calling a function inside console.log to get the balance, but we want to use a 
different approach. What we can do is rename the getBalance method to balance() and prefix it with a get keyword, so
now it is a getter method. 

- A getter is a method inside a class that we can use for getting the value of a property. Now with this syntax we can
access the balance property just like before but we cannot set it. We can also implement a setter so that we can get a
value and validate it. So we define a method with a set keyword as its prefix. Now using this syntax we can change the
value of the property just like before but the entered value would not be directly reflected in the balance property,
so anytime a value is entered this setter method is called and that would be the time for validation. 

-ls37: In JS we can create an object and add properties to it dynamically, but this is not possible in TS, because TS
is very strict aout the shape of objects. But there are situations where we need to add properties and this is where
we use Index Signatures. 

- Assume we want to write the application for ticketing concerts and we need to know who sits where. We are going to
define a class called SeatAssignment, we must say which seat belongs to who and we don't want to define individual
properties for each index for each row of seats. This where we use index signatures for creating properties 
dynamically. For this purpose we use square brackets and type the name of the property and use string type for it, so
that we can assign for instance A1 to it as a string. 

- We want to store a string in this property, we can store a string, object, etc in it. For now we will store a string
in it. So using index signatures we can create properties dynamically.

-ls38: Let's assume we want to create a ride sharing application like uber. We'll create a class called Ride and it
can have several properties for instance passenger and dropOfLocation. We don't want to worry about these properties
for now, instead we want to focus on keeping track of active rides. 

- We define a property with the type of number and initialize it as 0. We can also have methods like start and stop.
When we print the value of activeRides we'll see 1, but we expected to see 2. The reason is that we have two objects 
and each of them are in a separate space in memory. So each object is independently tracking active rides. Here we
need a single or global space where we can keep track of the active rides. This is where we use static properties. 
A static property is a property that belongs to a class and not an object. So we have 1 instance of it in memory.

- So first we have to prefix activeRides with the static keyword and also when we want to print the value of the said
property, we should use Ride instead of the names of objects. The 'this' keyword also references the current object so
we need to replace that with Ride as well. After making these changes we see 2 as the output.

- There is a problem with this implementation. The problem is that we can modify activeRides anywhere we want in our 
code. So we have to make the property private and define a public getter for reading its value. The getter is part of
an object at the time of creation, we have to use the static keyword for it to move it to the right class. 

- So when we create a static property, we would have just one instance of it for the class and not the objects.

-ls39: Sometimes we have two classes that share some properties and methods, it's not wise to write repetitive code
for them. Thise is where we use inheritance. We extract these common things that these two classes share and put
them in another class. And have the two classes inherit these commonalities. 

- The class that the others inherit from is known as Parent/Base/Super and the classes which inherit from the parent 
are known as Child/Derived/Sub. 

- We have created a new file and defined the Person class with two name properties, we have also defined a getter 
method for the full name which returns the combination of the first name and last name. We also define a method named
walk which prints walking.

- Now we create another class called Student and use the extend keyword to make it inherit everything from the Person 
class. We want to define a constructor for this class and define studentId as its parameter, but we'll get an error,
which says constructors for derived classes must contain a super call. We need to add the firstName and lastName 
parameters to the constructor to take care of the error. 

- We earlier found out that when we use the public keyword, we are creating a parameter property, so the compiler will
create this property and initialize it for us. For this case we don't want to use the public keyword for the name 
properties because we have already created them in the Person class. We also need to call the super function and pass 
the two name properties to completely solve the error. We can also define methods for this class.

- Now we create an instance of the student class, and we can see that we can access its properties, both the inherited
ones and the ones for the student class, such as names, studentId, and takeTest. The best practice is to define classes
in individual files, not in the same file.

-ls40: Sometimes we want to change something in the inherited code. For example we want to define a teacher class and
in order to use the get fullName function, we want to add the word 'professor' as a prefix for their names. So in the
teacher class we want to change the implementation of the fullName getter, this is called method overriding.

- We don't need the Student object anymore so we'll comment it out and create teacher class. We don't want to add any
properties to it so we don't need to define its own special constructor, it's going to inherit Person's constructor.
Now we're going to create an instance of the Teacher class. Now we want to copy the fulName getter and prefix its name 
with the word override to tell the compiler that we're overriding this method. 

- In the body of the new fullName getter, we're going to write the word Professor and concat it with super.fullName so
that we wouldn't have to write repetitive code. In this case we could achieve the same result without using the 
override keyword, however, it would be disconnected from the one defined in the base class (Person). We can enable a
compiler option to remind us to use the overrdie keyword. In the tsconfig.json file, type checking section, there is 
an option called noImplicitOverrdie which we can use. 

-ls41: One of the core principles of OOP is Polymorphism, which means many forms, which refers to a situation where an
object can take many forms.

- We have defined a function called printNames which takes an array of type Person as an argument. We want to call it
and give it an array of Person objects. Now we know that every student adn every teacehr is a person. So we can pass a
student object and a teacher object to this function. When we do so, we see that the way this application prints the
names of these two people are different and this is polymorphism in action. 

- If we define a class called Principal which inherits from Person, and override the fullName getter for it and instead
of Professor, print Principlal, since a Principal is also a Person, we can add a Principal object to the array and it 
is going to print the principal name according to the override method. Now we have enhanced our program without editing
the code for the printNames function. This brings us to another principle of OOP which is called Open Closed Principle.

- The Open Closed Principle says that our classes should be open for extension and closed for modification. So we should 
be able to inherit them or exend them but we shouldn't be able to modify them. If we change something in a class we might 
break something somewhere else. Practically, we cannot always adhere to this principle, because it can be costly and 
also impossible. 

-ls42: We have learned about public and private members in TS, now we want to learn more about the protected type. If
we make a method private, we can access it anywhere within the class but we cannot access it from outside. We even
wouldn't be able to acces it through an object created from that class. Protcted members are the same, we can access
them anywhere within the class but now the outside. The difference is that protected members are inherited but pirvate
members are not. 

- Protected members shouldn't be used that often within our applications unless we know what we are doing, because it 
can create coupling in our applications.

-ls43: Suppose we want to build an application and let the user draw shapes like rectangles, triangles, and so on. We
need to create a base class called Shape and we'll pass one parameter for its constructor called color of type string.
We also need to define a method called render for rendering the shape. But we don't know how to render the shape since
we need information about the shape in order to redner it. 

- So we will create another class called Circle which extends Shape, we need to pass radius of type number as one of 
the parameters, we also ned color to pass to the base class. Unlike radius, we didn't prefix color with the public
keyword because already defined this property in the base class. In the body of the constructor we call the super
method and pass color as its argument. 

- Now we want to override the render function in the Circle class and we can type the algorithm for rendering a circle
there. Similarly we could have other classes and implement the render method in them. There is a problem with the
current implementation. If we create in instance of a Shape, we shouldn't be able to render it but we can do it. This
is where we use abstract clases and methods. So if we want to prevent the creation of an instance of a class we should
mark it as abstract. 

- So we will prefix the Shape class with an abstract keyword which tells the compiler that this class is not ready to 
be instanciated and another class has to extend it. Also abstract methods are methods that have no implementation. 
So we also need to prefix the render method inside the Shape clas as abstract so it wouldn't have an implemenetation.
When we mark a method as abstract, we should annotate its return type as void since the default return type is any.

-ls44: We use an Interface to define the shape of an object. For example if we want to define a calendar, there are 
many calendars out there, we have Google Calendar, iCal, and so on. All these calendars have some commonalities which
we can define in a base class. We can define a parameter called name and a method called addEvent for it. The 
implementation of these methods depend on each one of these classes. For example how we record an event in Google Cal
is certainly different than how we do the same thing in Outlook. So tecnically we should make these class and methods
abstract. Abstract doesn't exist in JS, only in TS.

- Using an interface we should be able to say that all of our calendars should have the name property and the methods.
We will comment out the abstract class and define an interface. As we said there aren't interfaces in JS so it is only
used by the TS compiler to do type checking. Since in this application the calendar isn't providing any logic that the
subclasses can use, so in this case it is better to use an interface because it is more concise.

- Interfaces cannot have method implementation, so whenever we have some logic in our code we should use abstract class
instead of an interface. Inheritance also exists on interfaces, so we can define another interface which inherits from
the Calendar interface. 

- Now we need concrete implementation so we define a class called GoogleCalendar. When we say that this class extends 
the Calendar interface, the compiler complains that it doesn't implement the interface's methods and properties. If we
put the cursor on the class name, and press control and period, we wil see the option implement interface Calendar, and
if we select it, vscode will implement the needed property and methods.

- The editor implements the property like this: <name: string;> but we should manually replace it with a constructor 
which has the property as its parameter. So now we have a class that implements the Calendar interface, later we can
define a class like Outlook Calendar that implements the same interface. 

-ls46: To understand generics we need to know what problem they try to solve. Assume we want to represent a key-value pair.
We define a class called keyValuePair and define a constructor with two parameters for it. Now we create an object of
this class and assign the arguments to it. 

- We have defined the type of key as a number. If wanted to define another object somewhere else in the application and
assign a string to the key, we would encounter issues. We have these solutions. One solution is to set the type of the
key to any. But with this approach we lose type safety and it's better not to use it. The other solution is to duplicate
this class and call the copy StringKeyValuePair and create objects of this class when we want the key to be a string.
The problem is our code is redundant and also we may want to assign an object as the key in our code.

-ls47: To solve the problem we faced, we can type angled brackets <> and in between the brackets we can type one or more
generic type parameters. We can name the parameter anything we want but T is conventional, in cpp we call such calsses
template classes so here this generic is equivalent to that, and T is short for template. So we have defined a generic 
type parameter and now we can change the type of key from number to T.

- Now when we want to create an object of the KeyValuePair class, we can say what we want the type of the key to be. If
we choose number, we can se the proper methods for a number when we access it and also we can see other proper methods
for other types as well. 

- If we want, we can define the value as a generic type as well. All we should do is include two parameters in the angled
brackets and choose a name for them. If we don't supply the generic type arguments while creating an object, the compiler
will infer their types based on what we pass as arguments. 

-ls48: Just like generic classes, we can create generic functions as well. We have defined a function which creates an
array and puts the arguments inside it. We want to make it so every type can be passed to it so we have to make it a
generic function. So we define T as the generic type parameter and now the function can create an array of any type.

- We can define functions inside classes, so we define a class and put the function inside of it, but we have to remove
the function keyword anytime we define them inside of a class. With the current implementation we should create an object
of our class and then call the array method on this object. However, we can also make the method static which means that
it would belong to the class and then we wouldn't need an object to call it.

-ls49: Let's assume we have a website and we have an end-point for getting the list of the users and another end-point 
for getting the list of products. We'll define an interface (Result) for getting the result of one of these end-points. 
In the interface we set the type of data to T so it can be either users or products. We should also have a property
called error because we may not always get the proper result after trying to use an end-point.

- Since the function fetch returns a generic result, we should add the generic type parameter for it. Now we're going to
define two more interfaces, one for users and one for products. Now we want to see how we can use the fetch function
along with the two interfaces. If we don't type a generic type argument and simply type fetch(), we get Result<unknown>
so we have to so we have to explicitly decalre the generic type argument. 

- If we assign the result of the endpoint to a result variable, we can see that data is a user object and by typing a 
dot after data we can see all properties of the object. 

-ls50: Sometimes we need to constrain generic type arguments. We'll define a simple generic function that takes a value 
of type T and simply returns that value. Now we can call this function and give it a value of any type. But we may want
to limit the type of objects that we can pass to the function. We must use exted and say what types can be passed to
the function. Now when we call this function we can only pass arguments of these types to the it. 

- We can also constrain by the shape of an object. For instance we can pass a shape object called name of type string. 
Now we can only pass objects with this shape to the function. We can also constrain by an interface.

- We can also constrain by class, we have defined a class called People which has a constructor, now we we can pass an
instance of this class or any classes that derive from this class. 

-ls51: Assume we're building an e-commerce application, we can have objects like categories, shopping cart, etc. We'll
sart by defining an interface called Product and add two properties. We need a mechanism for storing these objects so 
we will define a class called Store and we want to be able to store different kinds of objects, so we'll make the class
generic. First we'll define a property called objects which is an array of type T in this class. It doesn't make sense
to create an instance of this class and give it an empty array so we don't want to create a constructor. So we're going
to initialize it by giving an empty array to the objects property. 

- We'll also define a method which gets an obj of type T to push new objects. In our current implementation, we can 
access the objects property from the outside but we shouldn't be able to because we can accidentally wipe out this array.
We can create a store object which is a Store of Product. We need to make objects private so it can only be accessed 
within the class. 

- We can also define a searchable store class and we want to implement a method in it which finds objects. This method
take a parameter called name of type string and returns T or undefined (in case cannot find the given object). Here if
we type this.objects, this property is not available because it is private and they are not inhertied in child classes.
To solve this problem we can make this property protected. 

- When we try to access obj.name in the find method's body, the compiler says that name does not exist on type T. Here
we can use constraints; We can say in the class' parameter, T extends an object with the shape that has a name property.
The object doesn't have to be a Product, it can be anything as long as it has a name property.

- In the last scenario, we assume there are certain opertaions that can only be performed on Products. In this scenario
we don't have a generic type after the name of the class because we're dealing with a very specific store. So we have
fixed the generic type parameter. In this class we define methods that ca be executed on products not other objects in
this class. 

-Key take-away: When extending a generic clas we have three options: we can fix the generic type parameter, we can 
restrict it, we can apply a constraint, or we can simply pass it on to the child class. 

-ls52: We're continuing working on the example from the previous session; we have the Product interface and the Store 
class. Now we want to implement a find method in this class. This method has two arguments and we should be able to
find any product with the passed property and value. The property parameter is of type string and the value can be of 
any type but we don't want to use this type for it, instead we're gonna use unknown. So if we pass the values to the
method, we either get an instance of T or undefined if there is no object that satisfies this criteria. 

- Now we want to see how we can use this implementation. So we create a store object and pass a product to it. We have 
run the find method twice on the store object with different arguments. There is a problem with this implementation. 
We can call this method and pass a non-existing property and when we run our program it is going to crash because there
is no product by this name in the Product interface. This is where we use the keyof operator to solve this problem.

- Eralier we learned that we use index signatures for dynamically adding properties to an object but in this case we're
not dealing with dynamic properties, we're dealing with actual properties of an object. To explicitly tell this to the 
compiler, we can change the type of property from string to keyof or property of T. So the property that we pass here 
can only be one of the keys or properties of type T. So the keyof operator returns a union of properties of the given 
type, and that is why we can only pass either a name or price when we're calling this method. So if we pass a 
non-existing property, we get a compile-time error.
 
-ls53: Sometimes we need to base a type on another type, this is called type mapping. For example here we have the 
Product interface with two properties, what if somewhere else in our application we need a Product with read-only 
properties. One option is to duplicate this interface and call the second one ReadOnlyProduct, and make each property
read-only. This is repetitive and also whenever we add a new property to the Product interface, we have to remember to
add that in the second interface as well. We can create a new type based on an existing type but in the new type we 
want to add all these properties dynamically and make them read-only. Here we want to create a type alias so we should
use the type keyword not interface, and we'll call it ReadOnlyProduct.

- Here we should use index signature and keyof operator. Instead of hard-coding the property names here, we're going to
use the index-signature syntax to dynamically add properties and using the keyof operator we're going to dynamically get
the properties of Product interface. Property on line 7, in one iteration is going to be name and in the second iteration
it is going to be price. We want to have the same types for these properties as we have used in the Product interface.
So we type Product[Property]. The K here could be anything, it could be Property but we Chose K for key.

- We have defined product of type ReadOnlyProduct. So when we access its properties, we cannot modify them since they
are read-only properties. Here we have limited ourselves to Product, but we can use a generic type and replace Product 
with a generic type parameter and then replace all Product instances with T. Now we can create a read-only Product or a
read-only customer or any kind of object.

- Using the same technique we can create a Product type with optional properties. One again we use the type keyword and
call this Optional and get all the keys of T, to make the properties optional we append a question mark at the end and 
for the type we use T[K]. Similarly we can deifne another type and make the properties nullable.

- If we look up utility types in Goole, we'll find all these types the the typescriptlang website.

-ls55: Decorators allow us to change and enhance our classes. Decorators are attributes that we apply to our classes
and their members to change how they behave. For example by applying the component decorator we can convert a class into
a component for a web-application. The component decorator and many more are not built into TS, that's why frameworks 
like Angular come with some built-in decorators.

- Before we create any decorators, first we have to enable a compiler option because they are an experimental feature
and their standards and implementation may change in the future. In the tsconfig file, in the Language and Environment 
section we have experimentalDecorators which we need to turn on. 

-ls56: a Decorator is simply a function that gets called by the JS Runtime. So first we'll define a function called 
Component, if we want to apply it to a class, it should have a single parameter that represents our constructor function. 
We can call it anything we want but what matters is the type, if the type is Function, the Runtime is going to assume
that we're going to apply it on a class. 

- In this function we have the chance to modify or enhance our class. We can add new properties or methods, change 
existing methods, or even delete properties and methods. We first type a console log in its body and then access the
prototype of the constructor where we can add properties or methods; then all instances of profile component or any
classes that have the component decorator, will inherit those properties and methods. 

- We define insertInDOM here so let's say every component should have a method for inseting it in the DOM, so when we
add a component in the DOM, then the browser is going to show that component to the user.  

- We could also take advantage of inheritance. So instead of defining the decorator, we could create a class called 
Component, define insertInDOM, and then we could have our ProfileComponent extend the Component class. It is another 
way to solve the same problem. 

- When we run our program, we get this message printed in the console "Component decorator called". So even though we
didn't create any instances of the Profile Component. So whether we have 0 or 10 instances, the decorator is called 
once and it is our chance to modify our classes. 

- If we take a look at the generated js file after compilation, we'll se a new function called __decorate which is 
automatically generated for our component and gets called with our decorator and class as arguments.

-ls57: 









