--** SECTION1 **--

- TypeScript is a programming language developed by Microsoft to address the shortcomings of JavaScript.

- Every JS file is a valid TS file.

- Features (Benefits) of TypeScript:
+Static Typing
+Code completion
+Refactoring
+Shorthand notations

* There are two types of programming languages: Statically-Typed and Dynamically-Typed
+In Staticaly-typed languages (eg. C#, Java) we know the type of variables at compile time (while coding) 
+In Dynamically-typed languages (eg. JS, Python) the types of variables are deteremined at runtime and can change

- In TS we explicitly declare the types of variables upon declaration

- The drawback of TS is there always is a compile time because we have to pass it through a TS compiler

- The process of turning TS code into JS code is called Transpilation

- We have installed the TSCompiler using <npm i -g typescript> and can check the version by running <tsv -v)

- To create a TS file, we run <tsc --init>

- The target setting in the config file is the version of JS that the compiler is going to generate.

- In the module section setting there is a rootDir setting which specifies the directory containing our source file

- After compilation, our JS files will be stored in the dist folder, so we change outDir under Emit to ./dist

- If we set removeComments to false, the compiler will remove all the comments

- If the noEmitOnError setting is true, if there are mistakes in our TS fiel, the compiler won't generate any JS

- If we run <tsc> in the terminal, the compiler will compiler our TS code

- The sourcemap setting is a file that specifies how each line of our TS code maps to the generated JS code

- For debugging, we navigate to the debugging panel, select create a launcfh.json file, then select Node.js

- In the launch.json file, we add a new setting under program named preLaunchTask and set to "tsc: build - tsconfig.json"
In this setting we tell vscode to compile our application using the tscompiler with this configuration

--** SECTION2: Fundamentals **--

- TS has some additional types compared with JS which makes it different than JS.

- In TS, we don't always have to annotate our variables. The compiler can infer or detect the type of our variabels
based on their values. For instance, when we initialize a variable to a number, the compiler knows that the variable
is a number. If we don't initialize a variable, the compiler will assume its type as any.

- When we define a variable with the type any, we can assign any value to it but it is against the whole idea of TS
so it wouldn't be logical.

- Assuming we have a JS project which uses undefined arguments in its functions, there are two things we can do, first, we can
define its type of any in where its used as an argument to tell the compiler that we know whart we're doing. The second
thing we can do is use control+p shortcut and go to tsconfig.json and set the noImplicitAny to false.

- Tuple is another data type which is a fixed length array where each element has a particular type. We often use them
while working with a pair of values.

- We can access the methods for arrays using a dot after the name of the array, one of the methods which can be 
troublesome is push(), so if we use it for a tuple, the compiler won't complain, Mosh suggests to only use tuples
while defining two elements, because more than that would be hard to figure out.

- Enum is another built-in data type which represents a list of related constants. (like C#)

- We have an option in the tsconfig.json file which allows us to avoid using unused arguments, so we wouldn't put
an argument in the parentheses which we're not going to use. In the typeChecking section we have an option called
noUnusedParameters which we can set to true.

- We have another option in tsconfig.json for detecting when we're not returning a proper value for a function, the 
option is called noImplicitReturns, we can set it to true and it will warn us when needed.

--** SECTION3: Advanced Types **--

- We can use a type alias to define a custom type. 

- With union (|) types, we can give a variable or a function parameter more than one type

- Another way to use multiple types for a variable is an intersection (&)

- Sometimes we want to limit the values we can assign to variables, here we use literals

- TS is strict about using null and undefined values in our apps because they are on of the main sources of bugs.

- If we hover over phone in the ls25 file, we see that it's either an HTML Element or null, in case it wasn't found.

- We have learned about the any type earlier in the course and know that we should avoid it as much as possible.

- If we define a function with an argument of type any, we can use whatever function we want and the compiler won't complain
but in runtime the app might crash.

- One thing we can do is change the type from any to unknown which will lead to the compiler complaining about using various
functions, we can also do type narrowing to use functions suitable for each type.

- In our tsconfig file, the type checking section, there is an option called allowUnreachableCode which we can turn off, now
in the never type file, we see that the compiler won't let us write any code after a function that doesn't return

- If we do not annotate the return type of an infinite loop function, the compiler will assume its void, and the code after
the function will not generate any errors.

--** SECTION4: Object-Oriented Programming **--

- OOP is one of the most important programming paradigms.

- An object is a unit that contains some data (also) and operations (behavior).

- If we consider a person an object, name and email would be properties, talk and dance could be methods for person.

- We could have individual objects for LoginForm, AuthService, EmailService, etc.

- A class is a blueprint for creating objects.

- If we want to represent the concept of a bank account, we need a class for that. We can have properties like id,
owner, and balance; we can also have methods like deposit, and withdraw.

- We use the Pascal naming convetion for classes (capitalize the first letter of EVERY word).

- A constructor is a special method inside a class, that is used for initializing an object.

- A constructor cannot have a return type annotation. 

- If we type this in a construcor and type a dot after it, we can see all the properties defined earlier. 

- After compilation when we look at the JS file, we see that we don't have any properties, we just have a constructor
where the types of arguments are not mentioned, and we also have the deposit method.

- In lesson 32, we will use the ls31 file and create an instance (object) of the defined class.

- We have created an object called account which is an instance of Account and passed the required arguments. When we
type account with dot after it, we can see the properties and methods for this object.

- We can use this command to compile a ts project in a specific path:
tsc -p D:\Projects\tsApps\section4OOP\ls31Class

- If we print the account object itself in the terminal, we will see all of its properties.

- If we print the typeof an object instance of a class, we get object.

- We can use instanceof to check to see whether an object is an insatnce of a specific class.

-ls33: In TS we have modifiers that we can apply to our properties and help us make more robust code. Let's say in our
code, the id of a bank account should never change, right now it can change. For example we can set its value to 0 in
the body of the deposit method. We can prefix this property with the readonly keyword and make it unchangeable. 

- Now let's say we want to define an optional property, for instance a nickname. We can add a question mark after the
property to make it optional. 

-ls34: There are more access control modifiers that we can use. Assume we want to implement a transaction on deposit
and withdraw, so we know how much money was transferred from who to where. We want to have an array for transactions 
which is an array of transaction objects. So before we change the balance we want to record the transaction. If we
want to modify the balance somewhere other than in the body of deposit, the transaction wouldn't be recorded and that
is a problem, so we should do something to limit access.

- In TypeScript we have 3 Access Modifiers. We have public, private and protected. When we define properties, they are
public by default. But if we use the private keyword for a property, it would be accessible only within that class. We
use this private keyword to make our code robust, not for storing private information. By convention, when we want to
make a property private, we prefix it with an underline. 

- We have made bance private, so when we want to display the balance to the user, we cannot access it because we are
outside of the Account class. One solution is to define a getBalance method inside the class which return the balance,
then we can call the method outside of the class for displaying the balance.

- We can also define private methods, so let's assume we want to define a calculateTax method and access it internally.

-ls35: In the constructor, we have 3 lines of code for initializing the three properties from the arguments. In the
line where we define the constructor, we can prefix the parameters with a public keyword, it tells the compiler to 
create a property with that name and initialize it in one go. This way we can get rid of the line at the top where 
we defined id as a readonly property and also the code in the constructor where we initialize it. We can also add the
readonly modifier for the parameter. These 3 keywords we used are parameter properties.

- ls36: With the current approach, we are calling a function inside console.log to get the balance, but we want to use a 
different approach. What we can do is rename the getBalance method to balance() and prefix it with a get keyword, so
now it is a getter method. 

- A getter is a method inside a class that we can use for getting the value of a property. Now with this syntax we can
access the balance property just like before but we cannot set it. We can also implement a setter so that we can get a
value and validate it. So we define a method with a set keyword as its prefix. Now using this syntax we can change the
value of the property just like before but the entered value would not be directly reflected in the balance property,
so anytime a value is entered this setter method is called and that would be the time for validation. 

-ls37: In JS we can create an object and add properties to it dynamically, but this is not possible in TS, because TS
is very strict aout the shape of objects. But there are situations where we need to add properties and this is where
we use Index Signatures. 

- Assume we want to write the application for ticketing concerts and we need to know who sits where. We are going to
define a class called SeatAssignment, we must say which seat belongs to who and we don't want to define individual
properties for each index for each row of seats. This where we use index signatures for creating properties 
dynamically. For this purpose we use square brackets and type the name of the property and use string type for it, so
that we can assign for instance A1 to it as a string. 

- We want to store a string in this property, we can store a string, object, etc in it. For now we will store a string
in it. So using index signatures we can create properties dynamically.

-ls38: Let's assume we want to create a ride sharing application like uber. We'll create a class called Ride and it
can have several properties for instance passenger and dropOfLocation. We don't want to worry about these properties
for now, instead we want to focus on keeping track of active rides. 

- We define a property with the type of number and initialize it as 0. We can also have methods like start and stop.
When we print the value of activeRides we'll see 1, but we expected to see 2. The reason is that we have two objects 
and each of them are in a separate space in memory. So each object is independently tracking active rides. Here we
need a single or global space where we can keep track of the active rides. This is where we use static properties. 
A static property is a property that belongs to a class and not an object. So we have 1 instance of it in memory.

- So first we have to prefix activeRides with the static keyword and also when we want to print the value of the said
property, we should use Ride instead of the names of objects. The 'this' keyword also references the current object so
we need to replace that with Ride as well. After making these changes we see 2 as the output.

- There is a problem with this implementation. The problem is that we can modify activeRides anywhere we want in our 
code. So we have to make the property private and define a public getter for reading its value. The getter is part of
an object at the time of creation, we have to use the static keyword for it to move it to the right class. 

- So when we create a static property, we would have just one instance of it for the class and not the objects.

-ls39: Sometimes we have two classes that share some properties and methods, it's not wise to write repetitive code
for them. Thise is where we use inheritance. We extract these common things that these two classes share and put
them in another class. And have the two classes inherit these commonalities. 

- The class that the others inherit from is known as Parent/Base/Super and the classes which inherit from the parent 
are known as Child/Derived/Sub. 

- We have created a new file and defined the Person class with two name properties, we have also defined a getter 
method for the full name which returns the combination of the first name and last name. We also define a method named
walk which prints walking.

- Now we create another class called Student and use the extend keyword to make it inherit everything from the Person 
class. We want to define a constructor for this class and define studentId as its parameter, but we'll get an error,
which says constructors for derived classes must contain a super call. We need to add the firstName and lastName 
parameters to the constructor to take care of the error. 

- We earlier found out that when we use the public keyword, we are creating a parameter property, so the compiler will
create this property and initialize it for us. For this case we don't want to use the public keyword for the name 
properties because we have already created them in the Person class. We also need to call the super function and pass 
the two name properties to completely solve the error. We can also define methods for this class.

- Now we create an instance of the student class, and we can see that we can access its properties, both the inherited
ones and the ones for the student class, such as names, studentId, and takeTest. The best practice is to define classes
in individual files, not in the same file.

-ls40: Sometimes we want to change something in the inherited code. For example we want to define a teacher class and
in order to use the get fullName function, we want to add the word 'professor' as a prefix for their names. So in the
teacher class we want to change the implementation of the fullName getter, this is called method overriding.

- We don't need the Student object anymore so we'll comment it out and create teacher class. We don't want to add any
properties to it so we don't need to define its own special constructor, it's going to inherit Person's constructor.
Now we're going to create an instance of the Teacher class. Now we want to copy the fulName getter and prefix its name 
with the word override to tell the compiler that we're overriding this method. 

- In the body of the new fullName getter, we're going to write the word Professor and concat it with super.fullName so
that we wouldn't have to write repetitive code. In this case we could achieve the same result without using the 
override keyword, however, it would be disconnected from the one defined in the base class (Person). We can enable a
compiler option to remind us to use the overrdie keyword. In the tsconfig.json file, type checking section, there is 
an option called noImplicitOverrdie which we can use. 

-ls41: One of the core principles of OOP is Polymorphism, which means many forms, which refers to a situation where an
object can take many forms.

- We have defined a function called printNames which takes an array of type Person as an argument. We want to call it
and give it an array of Person objects. Now we know that every student adn every teacehr is a person. So we can pass a
student object and a teacher object to this function. When we do so, we see that the way this application prints the
names of these two people are different and this is polymorphism in action. 

- If we define a class called Principal which inherits from Person, and override the fullName getter for it and instead
of Professor, print Principlal, since a Principal is also a Person, we can add a Principal object to the array and it 
is going to print the principal name according to the override method. Now we have enhanced our program without editing
the code for the printNames function. This brings us to another principle of OOP which is called Open Closed Principle.

- The Open Closed Principle says that our classes should be open for extension and closed for modification. So we should 
be able to inherit them or exend them but we shouldn't be able to modify them. If we change something in a class we might 
break something somewhere else. Practically, we cannot always adhere to this principle, because it can be costly and 
also impossible. 

-ls42: We have learned about public and private members in TS, now we want to learn more about the protected type. If
we make a method private, we can access it anywhere within the class but we cannot access it from outside. We even
wouldn't be able to acces it through an object created from that class. Protcted members are the same, we can access
them anywhere within the class but now the outside. The difference is that protected members are inherited but pirvate
members are not. 

- Protected members shouldn't be used that often within our applications unless we know what we are doing, because it 
can create coupling in our applications.

-ls43: Suppose we want to build an application and let the user draw shapes like rectangles, triangles, and so on. We
need to create a base class called Shape and we'll pass one parameter for its constructor called color of type string.
We also need to define a method called render for rendering the shape. But we don't know how to render the shape since
we need information about the shape in order to redner it. 

- So we will create another class called Circle which extends Shape, we need to pass radius of type number as one of 
the parameters, we also ned color to pass to the base class. Unlike radius, we didn't prefix color with the public
keyword because already defined this property in the base class. In the body of the constructor we call the super
method and pass color as its argument. 

- Now we want to override the render function in the Circle class and we can type the algorithm for rendering a circle
there. Similarly we could have other classes and implement the render method in them. There is a problem with the
current implementation. If we create in instance of a Shape, we shouldn't be able to render it but we can do it. This
is where we use abstract clases and methods. So if we want to prevent the creation of an instance of a class we should
mark it as abstract. 

- So we will prefix the Shape class with an abstract keyword which tells the compiler that this class is not ready to 
be instanciated and another class has to extend it. Also abstract methods are methods that have no implementation. 
So we also need to prefix the render method inside the Shape clas as abstract so it wouldn't have an implemenetation.
When we mark a method as abstract, we should annotate its return type as void since the default return type is any.

-ls44: We use an Interface to define the shape of an object. For example if we want to define a calendar, there are 
many calendars out there, we have Google Calendar, iCal, and so on. All these calendars have some commonalities which
we can define in a base class. We can define a parameter called name and a method called addEvent for it. The 
implementation of these methods depend on each one of these classes. For example how we record an event in Google Cal
is certainly different than how we do the same thing in Outlook. So tecnically we should make these class and methods
abstract. Abstract doesn't exist in JS, only in TS.

- Using an interface we should be able to say that all of our calendars should have the name property and the methods.
We will comment out the abstract class and define an interface. As we said there aren't interfaces in JS so it is only
used by the TS compiler to do type checking. Since in this application the calendar isn't providing any logic that the
subclasses can use, so in this case it is better to use an interface because it is more concise.

- Interfaces cannot have method implementation, so whenever we have some logic in our code we should use abstract class
instead of an interface. Inheritance also exists on interfaces, so we can define another interface which inherits from
the Calendar interface. 

- Now we need concrete implementation so we define a class called GoogleCalendar. When we say that this class extends 
the Calendar interface, the compiler complains that it doesn't implement the interface's methods and properties. If we
put the cursor on the class name, and press control and period, we wil see the option implement interface Calendar, and
if we select it, vscode will implement the needed property and methods.

- The editor implements the property like this: <name: string;> but we should manually replace it with a constructor 
which has the property as its parameter. So now we have a class that implements the Calendar interface, later we can
define a class like Outlook Calendar that implements the same interface. 

-ls46: To understand generics we need to know what problem they try to solve. Assume we want to represent a key-value pair.
We define a class called keyValuePair and define a constructor with two parameters for it. Now we create an object of
this class and assign the arguments to it. 

- We have defined the type of key as a number. If wanted to define another object somewhere else in the application and
assign a string to the key, we would encounter issues. We have these solutions. One solution is to set the type of the
key to any. But with this approach we lose type safety and it's better not to use it. The other solution is to duplicate
this class and call the copy StringKeyValuePair and create objects of this class when we want the key to be a string.
The problem is our code is redundant and also we may want to assign an object as the key in our code.

-ls47: To solve the problem we faced, we can type angled brackets <> and in between the brackets we can type one or more
generic type parameters. We can name the parameter anything we want but T is conventional, in cpp we call such calsses
template classes so here this generic is equivalent to that, and T is short for template. So we have defined a generic 
type parameter and now we can change the type of key from number to T.

- Now when we want to create an object of the KeyValuePair class, we can say what we want the type of the key to be. If
we choose number, we can se the proper methods for a number when we access it and also we can see other proper methods
for other types as well. 

- If we want, we can define the value as a generic type as well. All we should do is include two parameters in the angled
brackets and choose a name for them. If we don't supply the generic type arguments while creating an object, the compiler
will infer their types based on what we pass as arguments. 

-ls48: Just like generic classes, we can create generic functions as well. We have defined a function which creates an
array and puts the arguments inside it. We want to make it so every type can be passed to it so we have to make it a
generic function. So we define T as the generic type parameter and now the function can create an array of any type.

- We can define functions inside classes, so we define a class and put the function inside of it, but we have to remove
the function keyword anytime we define them inside of a class. With the current implementation we should create an object
of our class and then call the array method on this object. However, we can also make the method static which means that
it would belong to the class and then we wouldn't need an object to call it.

- 












